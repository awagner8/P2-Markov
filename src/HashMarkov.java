import java.util.*;

/**
 * Implements the MarkovInterface to generate random text based
 * on a training text. Searches over training text to generate
 * each random word of generated text.
 * For use in Compsci 201, Fall 2022, Duke University
 * @author ola
 * @author Brandon Fain
 */

public class HashMarkov implements MarkovInterface {
	
	protected String[] myWords;		// Training text split into array of words 
	protected Random myRandom;		// Random number generator
	protected int myOrder;			// Length of WordGrams used
    protected HashMap<WordGram, ArrayList<String>> myMap;
	
	/**
	 * Default constructor creates order 2 model
	 */
	public HashMarkov() {
		this(2);
	}


	/**
	 * Initializes a model of given order and random number generator.
	 * @param order Number of words used to generate next 
	 * random word / size of WordGrams used.
	 */
	public HashMarkov(int order){
		myOrder = order;
		myRandom = new Random();
		myMap = new HashMap<>();
	}
	

	/**
	 * Initializes training text. Should always be called prior to
	 * random text generation.
	 */
	@Override
	public void setTraining(String text){
		myWords = text.split("\\s+");
        myMap.clear();
		int runTime = myWords.length-myOrder;
		for (int i = 0; i<runTime; i++){
			WordGram keyGram = new WordGram(myWords, i, myOrder);
			myMap.putIfAbsent(keyGram, new ArrayList<String>());
			ArrayList<String> working = myMap.get(keyGram);
			working.add(myWords[myOrder+i]);
			myMap.put(keyGram, working);
		}
	}


	/**
	 * Get a list of Strings containing all words that follow
	 * from wgram in the training text. Result may be an empty list.
	 * Implemented by looping over training text.
	 * @param wgram is a WordGram to search for in the text
	 * @return List of words following wgram in training text.
	 * May be empty.
	 */
	@Override
	public List<String> getFollows(WordGram wgram) {	
		if (!myMap.containsKey(wgram)){
			List<String> returnEmpty = new ArrayList<>();
			return returnEmpty;
		}
		return myMap.get(wgram);
		
	}


	/**
	 * Returns a random word that follows kGram in the training text.
	 * In case no word follows kGram, returns a random word from the
	 * entire training text.
	 * @param wgram is being searched for in training text. Typically
	 * the previous words of the randomly generated text, but could be
	 * an arbitrary WordGram.
	 * @return a random word among those that follow after kGram in 
	 * the training text, or a random word from the training text.
	 */
	private String getNext(WordGram wgram) {
		List<String> follows = getFollows(wgram);
		if (follows.size() == 0) {
			int randomIndex = myRandom.nextInt(myWords.length);
			return myWords[randomIndex];
		}
		else {
			int randomIndex = myRandom.nextInt(follows.size());
			return follows.get(randomIndex);
		}
	}


	/**
	 * Generates length random words based on training text.
	 * Initial words are a random WordGram taken from the training text.
	 * Subsequent words are generated by calling getNext on the current
	 * WordGram, which is then shifted to include the newly generated 
	 * word at the end. Words are separated by spaces in returned string.
	 * @param length Number of words to generate
	 * @returns length randomly generated words using Markov model, 
	 * separated by spaces
	 */
	@Override
	public String getRandomText(int length){
		ArrayList<String> randomWords = new ArrayList<String>();
		int randomIndex = myRandom.nextInt(myWords.length - myOrder + 1);
		WordGram current = new WordGram(myWords,randomIndex,myOrder);
		randomWords.add(current.toString());
		for(int i=0; i < length-myOrder; i++) {
			ArrayList<String> follows = myMap.get(current);
			String nextWord; 
			if (follows == null) {
				int rI = myRandom.nextInt(myWords.length);
				nextWord = myWords[rI];
			}
			else {
				int rI = myRandom.nextInt(follows.size());
				nextWord = follows.get(rI);
			}
			randomWords.add(nextWord);
			current = current.shiftAdd(nextWord);
		}
		return String.join(" ", randomWords);
	}

	/**
	 * Returns order of Markov model = the length of
	 * WordGrams used.
	 */
	@Override
	public int getOrder() {
		return myOrder;
	}


	/**
	 * Sets the seed of the random number generator
	 * Model will return same value when called with 
	 * same training text after same seed set.
	 * @param seed Random number generator seed
	 */
	@Override
	public void setSeed(long seed) {
		myRandom.setSeed(seed);
	}
	
	
}

/* import java.util.*;

public class HashMarkov implements MarkovInterface {

    protected HashMap<WordGram, List<String>> myMap;
    protected String[] myWords;		// Training text split into array of words 
	protected Random myRandom;		// Random number generator
	protected int myOrder;
    
    public HashMarkov() {
		this(3);
	}

    public HashMarkov(int order) {
        myOrder = order;
        myRandom = new Random();
        myMap = new HashMap<>();
    } 


    @Override
    public void setTraining(String text) {
        myWords = text.split("\\s+");
        myMap.clear();
        WordGram wg = new WordGram(myWords, 0, myOrder);
        for(int k =myOrder; k < myWords.length; k++){
            if(!myMap.containsKey(wg)) myMap.put(wg, new ArrayList<String>());
            myMap.get(wg).add(myWords[k]);
            wg = wg.shiftAdd(myWords[k]);
        }
    }        
            

    @Override
    public List<String> getFollows(WordGram wgram) {
        if (!myMap.containsKey(wgram)){
			List<String> Empty = new ArrayList<>();
			return Empty;
		}
		return myMap.get(wgram);
    }

    	/**
	 * Generates length random words based on training text.
	 * Initial words are a random WordGram taken from the training text.
	 * Subsequent words are generated by calling getNext on the current
	 * WordGram, which is then shifted to include the newly generated 
	 * word at the end. Words are separated by spaces in returned string.
	 * @param length Number of words to generate
	 * @returns length randomly generated words using Markov model, 
	 * separated by spaces
	 */
    /*@Override
    public String getRandomText(int length) {
        ArrayList<String> randomWords = new ArrayList<>();
        int index = myRandom.nextInt(myWords.length - myOrder+1);
        WordGram current = new WordGram(myWords, index, myOrder);
        randomWords.add(current.toString());
        for(int k = 0; k < length - myOrder; k++){
            List<String> follows = getFollows(current);
            String next = "";
            if(follows.size() == 0) {
                int random = myRandom.nextInt(myWords.length);
                next = myWords[random];
            }
            else{
                index = myRandom.nextInt(follows.size());
                next = follows.get(index);
            }
            randomWords.add(next);
            current = current.shiftAdd(next);
        }


		return String.join(" ", randomWords);
	}


    @Override
    public int getOrder() {
        return myOrder;
    }

    @Override
    public void setSeed(long seed) {
        myRandom.setSeed(seed);
    }
    
}*/
